- name: Build README checklist
  id: build
  uses: actions/github-script@v7
  with:
    result-encoding: string
    script: |
      const path = require('path');
      const fs = require('fs');
      const {owner, repo} = context.repo;
      const pr = context.payload.pull_request?.number;
      if (!pr) {
        core.setOutput('result', 'Not a PR run');
        return 'Not a PR run';
      }

      let page = 1, per_page = 100, touchedDirs = new Set(), changedByDir = {};
      const IGNORE_PREFIXES = ['.github', '.git', '_site', 'scripts', '.vscode', '.idea'];
      while (true) {
        const {data: files} = await github.rest.pulls.listFiles({
          owner, repo, pull_number: pr, per_page, page
        });
        if (!files.length) break;
        for (const f of files) {
          const dir = path.posix.dirname(f.filename);
          if (IGNORE_PREFIXES.some(p => dir === p || dir.startsWith(p + '/'))) continue;
          touchedDirs.add(dir);
          changedByDir[dir] = changedByDir[dir] || [];
          changedByDir[dir].push(f);
        }
        if (files.length < per_page) break;
        page += 1;
      }
      // Only process the first 500 touched directories
      const touchedDirsArr = Array.from(touchedDirs).sort();
      const limit = 500;
      const limitedDirs = touchedDirsArr.slice(0, limit);
      const omittedCount = touchedDirsArr.length > limit ? touchedDirsArr.length - limit : 0;

      const ws = process.env.GITHUB_WORKSPACE;
      const readmeRegex = new RegExp(`^(?:${process.env.README_CANDIDATES})$`, 'i');

      function findReadmeName(dir) {
        try {
          const full = path.join(ws, dir);
          const entries = fs.existsSync(full) ? fs.readdirSync(full) : [];
          for (const e of entries) {
            if (readmeRegex.test(e)) return e;
          }
        } catch {}
        return null;
      }

      const rows = [];
      for (const dir of limitedDirs) {
        const readme = findReadmeName(dir);
        const changes = changedByDir[dir] || [];
        const readmeChanged = readme
          ? changes.some(f => path.posix.basename(f.filename).toLowerCase() === readme.toLowerCase())
          : false;
        const nonReadmeChanged = changes.some(f => !/readme/i.test(path.posix.basename(f.filename)));
        let status = 'OK';
        if (!readme) status = 'MISSING';
        else if (nonReadmeChanged && !readmeChanged) status = 'NEEDS_UPDATE';
        rows.push({dir, readme: readme || '-', status});
      }

      const repoUrl = context.payload.repository.html_url;
      const headSha = context.payload.pull_request.head.sha;
      const copilot = (process.env.COPILOT_HANDLE || '').trim() || '@copilot';

      function linkToDir(d) { return `${repoUrl}/tree/${headSha}/${d}`; }

      let body = `**üìö README review checklist** (ping ${copilot})\n\n`;
      body += `Folders touched in this PR: **${touchedDirsArr.length}**\n\n`;

      if (omittedCount > 0) {
        body += `‚ö†Ô∏è _Only the first ${limit} folders are listed below. ${omittedCount} additional folders are not shown._\n\n`;
      }

      const missing = rows.filter(r => r.status === 'MISSING');
      const needs = rows.filter(r => r.status === 'NEEDS_UPDATE');

      if (missing.length) {
        body += `### ‚ùå Missing README\n`;
        for (const r of missing) body += `- [ ] \`${r.dir}\` ‚Äî add \`README.md\` ([open folder](${linkToDir(r.dir)}))\n`;
        body += `\n`;
      }
      if (needs.length) {
        body += `### ‚ö†Ô∏è Needs update (folder changed, README not updated)\n`;
        for (const r of needs) body += `- [ ] \`${r.dir}\` ‚Äî update \`${r.readme}\` ([open folder](${linkToDir(r.dir)}))\n`;
        body += `\n`;
      }
      if (!missing.length && !needs.length) {
        body += `### ‚úÖ All good\nAll touched folders have an up-to-date README.\n\n`;
      }

      body += `<sub>Accepted README names: ${process.env.README_CANDIDATES.replace(/\|/g, ', ')}</sub>\n`;

      core.setOutput('result', body);
      return body;
