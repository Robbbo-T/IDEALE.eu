name: README Reminder

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review, edited]

permissions:
  contents: read
  pull-requests: write

env:
  # Accepted README filenames (case-insensitive, pipe-separated)
  README_CANDIDATES: README.md|README.MD|Readme.md|README|readme.md
  # Folders to ignore (comma-separated, repo-root relative)
  IGNORE_PREFIXES: .github,.git,_site,scripts,.vscode,.idea
  # Max folders to list in large PRs
  MAX_DIRS: "500"
  # Optional mention at the top of the checklist
  COPILOT_HANDLE: "@copilot"

jobs:
  readme-checklist:
    name: Build README checklist
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build README checklist
        id: build
        uses: actions/github-script@v7
        with:
          result-encoding: string
          script: |
            const path = require('path');
            const fs = require('fs');

            const { owner, repo } = context.repo;
            const pr = context.payload.pull_request?.number;

            if (!pr) {
              core.setOutput('result', 'Not a PR run');
              return 'Not a PR run';
            }

            // Config
            const MAX_DIRS = parseInt(process.env.MAX_DIRS || '500', 10);
            const IGNORE_PREFIXES = (process.env.IGNORE_PREFIXES || '.github,.git,_site,scripts,.vscode,.idea')
              .split(',')
              .map(s => s.trim())
              .filter(Boolean);

            // Safer README candidates: anchor each candidate
            const candidates = (process.env.README_CANDIDATES || 'README.md|README')
              .split('|').map(s => s.trim()).filter(Boolean)
              .map(s => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')); // escape
            const readmeRegex = new RegExp(`^(?:${candidates.join('|')})$`, 'i');

            const touchedDirs = new Set();
            const changedByDir = {};

            let page = 1, per_page = 100;

            // Collect changed files (handle pagination, renames, deletions)
            while (true) {
              const { data: files } = await github.rest.pulls.listFiles({
                owner, repo, pull_number: pr, per_page, page
              });
              if (!files.length) break;

              for (const f of files) {
                const currentPath = f.filename;
                const prevPath = f.previous_filename;

                const dirsToMark = new Set();

                const addDir = (p) => {
                  let dir = path.posix.dirname(p);
                  if (!dir || dir === '') dir = '.'; // repo root
                  // Ignore configured prefixes
                  if (IGNORE_PREFIXES.some(prefix => dir === prefix || dir.startsWith(prefix + '/'))) return;
                  dirsToMark.add(dir);
                };

                addDir(currentPath);
                if (f.status === 'renamed' && prevPath) addDir(prevPath);

                for (const dir of dirsToMark) {
                  touchedDirs.add(dir);
                  changedByDir[dir] = changedByDir[dir] || [];
                  changedByDir[dir].push(f);
                }
              }

              if (files.length < per_page) break;
              page += 1;
            }

            // Limit to first N directories for very large PRs
            const touchedDirsArr = Array.from(touchedDirs).sort();
            const limitedDirs = touchedDirsArr.slice(0, MAX_DIRS);
            const omittedCount = Math.max(0, touchedDirsArr.length - limitedDirs.length);

            // Workspace FS view (HEAD of PR)
            const ws = process.env.GITHUB_WORKSPACE;

            function findReadmeName(dir) {
              try {
                const full = path.join(ws, dir);
                if (!fs.existsSync(full)) return null; // dir deleted or not checked out
                const entries = fs.readdirSync(full, { withFileTypes: true });
                for (const ent of entries) {
                  if (ent.isFile() && readmeRegex.test(ent.name)) return ent.name;
                }
              } catch (e) {
                // Ignore FS errors and treat as missing
              }
              return null;
            }

            const rows = [];
            for (const dir of limitedDirs) {
              const readme = findReadmeName(dir);
              const changes = changedByDir[dir] || [];

              const readmeChanged = readme
                ? changes.some(f => path.posix.basename(f.filename).toLowerCase() === readme.toLowerCase())
                : false;

              const nonReadmeChanged = changes.some(f => !/readme/i.test(path.posix.basename(f.filename)));

              let status = 'OK';
              if (!readme) status = 'MISSING';
              else if (nonReadmeChanged && !readmeChanged) status = 'NEEDS_UPDATE';

              rows.push({ dir, readme: readme || '-', status });
            }

            // Compose checklist body
            const repoUrl = context.payload.repository.html_url;
            const headSha = context.payload.pull_request.head.sha;
            const copilot = (process.env.COPILOT_HANDLE || '').trim() || '@copilot';
            const linkToDir = (d) => `${repoUrl}/tree/${headSha}/${d}`;

            let body = `**üìö README review checklist** (ping ${copilot})\n\n`;
            body += `Folders touched in this PR: **${touchedDirsArr.length}**\n\n`;

            if (omittedCount > 0) {
              body += `‚ö†Ô∏è _Only the first ${MAX_DIRS} folders are listed below. ${omittedCount} additional folders are not shown._\n\n`;
            }

            const missing = rows.filter(r => r.status === 'MISSING');
            const needs = rows.filter(r => r.status === 'NEEDS_UPDATE');

            if (missing.length) {
              body += `### ‚ùå Missing README\n`;
              for (const r of missing) body += `- [ ] \`${r.dir}\` ‚Äî add \`README.md\` ([open folder](${linkToDir(r.dir)}))\n`;
              body += `\n`;
            }
            if (needs.length) {
              body += `### ‚ö†Ô∏è Needs update (folder changed, README not updated)\n`;
              for (const r of needs) body += `- [ ] \`${r.dir}\` ‚Äî update \`${r.readme}\` ([open folder](${linkToDir(r.dir)}))\n`;
              body += `\n`;
            }
            if (!missing.length && !needs.length) {
              body += `### ‚úÖ All good\nAll listed folders have an up-to-date README.\n\n`;
            }

            body += `<sub>Accepted README names: ${candidates.join(', ')}</sub>\n`;

            core.setOutput('result', body);
            return body;

      - name: Post checklist comment
        if: ${{ github.event_name == 'pull_request' }}
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: "üìö README review checklist"
          message: ${{ steps.build.outputs.result }}

