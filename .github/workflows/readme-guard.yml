name: README auto-instructions (PR/fork-safe)

on:
  pull_request_target:
    types: [opened, reopened, synchronize, ready_for_review]
  workflow_dispatch:
    inputs:
      pr_number:
        description: "PR number to post instructions to"
        required: true
        type: string

permissions:
  contents: read          # read repo metadata / PR files / base tree
  pull-requests: write    # post comments / request reviewers
  issues: write           # sticky comment action uses Issues API

concurrency:
  group: readme-instructor-${{ github.event.pull_request.number || inputs.pr_number }}
  cancel-in-progress: true

env:
  COPILOT_HANDLE: "@copilot"
  README_CANDIDATES: "README.md|README-PAGES.md|Readme.md|README"
  DOC_EXTS: "md,rst,txt,adoc"
  ASSET_EXTS: "png,jpg,jpeg,svg,gif,pdf,drawio"
  IGNORE_PREFIXES: ".github,.git,_site,scripts,.vscode,.idea,dist,build,target,node_modules,vendor,__pycache__,.venv,.next"

jobs:
  instruct:
    runs-on: ubuntu-latest
    steps:
      - name: Build Copilot instruction (API only; no checkout)
        id: build
        uses: actions/github-script@v7
        with:
          result-encoding: string
          script: |
            const path = require('path');
            const { owner, repo } = context.repo;

            // Determine PR number (event or manual)
            let prNumber = core.getInput('pr_number');
            if (!prNumber) prNumber = context.payload.pull_request?.number;
            if (!prNumber) {
              const msg = 'No PR number found (not a PR event and no workflow_dispatch input).';
              core.setOutput('result', msg);
              return msg;
            }

            // Load PR & changed files (base context only)
            const pr = (await github.rest.pulls.get({ owner, repo, pull_number: prNumber })).data;
            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner, repo, pull_number: prNumber, per_page: 100
            });

            const README_CANDS = (process.env.README_CANDIDATES || 'README.md').split('|');
            const DOC_EXTS = new Set((process.env.DOC_EXTS || 'md').split(',').map(s=>s.trim().toLowerCase()).filter(Boolean));
            const ASSET_EXTS = new Set((process.env.ASSET_EXTS || '').split(',').map(s=>s.trim().toLowerCase()).filter(Boolean));
            const IGNORE_PREFIXES = (process.env.IGNORE_PREFIXES || '').split(',').map(s=>s.trim()).filter(Boolean);

            const isIgnored = dir => IGNORE_PREFIXES.some(p => dir === p || dir.startsWith(p + '/'));
            const extOf = f => path.posix.extname(f).toLowerCase().replace(/^\./,'');
            const baseOf = f => path.posix.basename(f);
            const repoUrl = context.payload.repository.html_url;
            const headSha = pr.head.sha;
            const baseRef = pr.base.ref;
            const headRef = pr.head.ref;
            const copilotHandle = (process.env.COPILOT_HANDLE || '@copilot').trim();

            // Group changes by directory
            const dirs = new Map();
            const ensure = (d) => {
              if (!dirs.has(d)) dirs.set(d, {
                readmeTouched: false,
                readmeAdded: false,
                nonDocFiles: [],
              });
              return dirs.get(d);
            };

            for (const f of files) {
              if (f.status === 'removed') continue;
              const dir = path.posix.dirname(f.filename) || '.';
              if (isIgnored(dir)) continue;

              const info = ensure(dir);
              const name = baseOf(f.filename);
              const ext  = extOf(f.filename);

              const isReadmeCand = README_CANDS.some(r => r.toLowerCase() === name.toLowerCase());
              if (isReadmeCand) {
                info.readmeTouched = true;
                if (f.status === 'added') info.readmeAdded = true;
              } else if (!DOC_EXTS.has(ext) && !ASSET_EXTS.has(ext)) {
                info.nonDocFiles.push(f.filename);
              }
            }

            // Helper: is there a README in this dir on base branch?
            async function baseHasReadme(dir) {
              const prefix = dir === '.' ? '' : (dir + '/');
              for (const cand of README_CANDS) {
                try {
                  await github.rest.repos.getContent({
                    owner, repo,
                    path: prefix + cand,
                    ref: pr.base.sha
                  });
                  return cand; // exists on base
                } catch (_) { /* no-op */ }
              }
              return null;
            }

            // Build tasks WITHOUT reading the fork
            const tasks = [];
            for (const [dir, info] of [...dirs.entries()].sort((a,b)=>a[0].localeCompare(b[0]))) {
              if (info.nonDocFiles.length === 0) continue;     // only when "real" files changed
              if (info.readmeTouched) continue;                 // author already handled README

              const baseReadme = await baseHasReadme(dir);
              const status = baseReadme ? 'NEEDS_UPDATE' : 'MISSING';

              const link = dir === '.' ? `${repoUrl}/tree/${headSha}` : `${repoUrl}/tree/${headSha}/${dir}`;
              tasks.push({
                dir, status, baseReadme,
                changed: info.nonDocFiles,
                link
              });
            }

            let body = `@${copilotHandle.replace(/^@/,'')}\n\n`;
            body += `**Role:** Senior documentation engineer.\n`;
            body += `**Goal:** Generate or update folder READMEs to reflect *code/config* changes in this PR.\n\n`;
            body += `**Branch:** \`${headRef}\` (base: \`${baseRef}\`)\n`;
            body += `**Head commit:** \`${headSha}\`\n\n`;
            body += `**Instructions:** For each task below, reply with *multi-file patch* blocks that either **add** \`README.md\` if missing or **update** the existing README. Use:\n`;
            body += `- Sections: Title, Overview, Contents, How it fits (interfaces/contracts), Setup/Usage, Evidence (SBOM/UTCS links), Tests, Owners, Changelog (this PR).\n`;
            body += `- Concise Markdown, relative links, reflect the files actually changed.\n\n`;
            body += `**Patch examples:**\n`;
            body += "```patch\n*** Begin Patch\n*** Add File: path/to/README.md\n# Title\n...\n*** End Patch\n```\n";
            body += "```patch\n*** Begin Patch\n*** Update File: path/to/README.md\n- old line\n+ new line\n*** End Patch\n```\n\n";

            if (!tasks.length) {
              body += `âœ… No README generation/update needed (either no code changes or README already updated).\n`;
              core.setOutput('result', body);
              return body;
            }

            for (const t of tasks) {
              body += `---\n`;
              body += `### Task: \`${t.dir}\` â†’ ${t.status === 'MISSING' ? 'Create README.md' : 'Update existing README'}\n`;
              body += `- Folder: ${t.link}\n`;
              if (t.baseReadme) body += `- Existing on base: \`${t.baseReadme}\`\n`;
              body += `- Changed files (non-doc):\n`;
              for (const f of t.changed) body += `  - \`${f}\`\n`;
              body += `- Start from this skeleton:\n\`\`\`md\n# ${path.posix.basename(t.dir) || repo}\n\n## Overview\n<what this folder does>\n\n## Contents\n- <key files>\n\n## How it fits\n<context & interfaces>\n\n## Setup / Usage\n<commands>\n\n## Evidence\n- SBOM: (if any)\n- UTCS/CXP: (if any)\n\n## Tests\n<how to run>\n\n## Owners\n- <team/handles>\n\n## Changelog (this PR)\n- <summary>\n\`\`\`\n\n`;
            }

            core.setOutput('result', body);
            return body;

      - name: Post sticky comment
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: "ðŸ§­ Copilot: generate/update READMEs"
          message: ${{ steps.build.outputs.result }}

      - name: Label and request review from Copilot
        uses: actions/github-script@v7
        env:
          COPILOT_HANDLE: ${{ env.COPILOT_HANDLE }}
        with:
          script: |
            const pr = context.payload.pull_request?.number || core.getInput('pr_number');
            if (!pr) return;

            // Add label
            try {
              await github.rest.issues.addLabels({
                ...context.repo,
                issue_number: Number(pr),
                labels: ['copilot:readme-update-requested']
              });
            } catch (e) {
              core.info(`Label add failed: ${e.message}`);
            }

            // Request review (no-op if not a collaborator)
            const reviewer = (process.env.COPILOT_HANDLE || '').replace(/^@/,'').trim();
            if (reviewer) {
              try {
                await github.rest.pulls.requestReviewers({
                  ...context.repo,
                  pull_number: Number(pr),
                  reviewers: [reviewer],
                });
              } catch (e) {
                core.info(`Request reviewers failed: ${e.message}`);
              }
            }

      - name: Debug summary
        run: |
          echo "Instruction length: ${#INSTR}" >> $GITHUB_STEP_SUMMARY
          printf "%s\n" "${INSTR}" >> $GITHUB_STEP_SUMMARY
        env:
          INSTR: ${{ steps.build.outputs.result }}
